"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PBXProject = void 0;
const path_1 = __importDefault(require("path"));
const constants_1 = require("./utils/constants");
const json = __importStar(require("../json/types"));
const AbstractObject_1 = require("./AbstractObject");
const PBXNativeTarget_1 = require("./PBXNativeTarget");
const XCBuildConfiguration_1 = require("./XCBuildConfiguration");
class PBXProject extends AbstractObject_1.AbstractObject {
    static is(object) {
        return object.isa === PBXProject.isa;
    }
    static create(project, opts) {
        return project.createModel({
            isa: PBXProject.isa,
            ...opts,
        });
    }
    getObjectProps() {
        return {
            buildConfigurationList: String,
            mainGroup: String,
            productRefGroup: String,
            targets: [String],
            packageReferences: [String],
        };
    }
    setupDefaults(props) {
        if (!props.compatibilityVersion) {
            props.compatibilityVersion = "Xcode 3.2";
        }
        if (!props.developmentRegion) {
            props.developmentRegion = "en";
        }
        if (!props.hasScannedForEncodings) {
            props.hasScannedForEncodings = 0;
        }
        if (!props.knownRegions) {
            props.knownRegions = ["en", "Base"];
        }
        if (!props.projectDirPath) {
            props.projectDirPath = "";
        }
        if (!props.projectRoot) {
            props.projectRoot = "";
        }
        if (!props.attributes) {
            props.attributes = {
                LastSwiftUpdateCheck: constants_1.LAST_SWIFT_UPGRADE_CHECK,
                LastUpgradeCheck: constants_1.LAST_UPGRADE_CHECK,
                TargetAttributes: {},
            };
        }
    }
    addBuildConfiguration(name, type) {
        let configList = this.props.buildConfigurationList;
        const has = configList.props.buildConfigurations.find((config) => config.props.name === name);
        if (has)
            return has;
        const config = XCBuildConfiguration_1.XCBuildConfiguration.create(this.getXcodeProject(), {
            name,
            buildSettings: {
                ...JSON.parse(JSON.stringify(constants_1.PROJECT_DEFAULT_BUILD_SETTINGS.all)),
                ...JSON.parse(JSON.stringify(constants_1.PROJECT_DEFAULT_BUILD_SETTINGS[type])),
            },
        });
        configList.props.buildConfigurations.push(config);
        return config;
    }
    getName() {
        return path_1.default.basename(this.getXcodeProject().filePath, ".xcodeproj");
    }
    /**
     * Get or create the 'Products' group set as the `productRefGroup`.
     *
     * @returns The `productRefGroup` or a new group if it doesn't exist.
     */
    ensureProductGroup() {
        if (this.props.productRefGroup) {
            return this.props.productRefGroup;
        }
        // Create a "Products" group
        const group = this.props.mainGroup.createGroup({
            name: "Products",
            sourceTree: "<group>",
        });
        this.props.productRefGroup = group;
        return group;
    }
    /**
     * Get or create the child group for a given name in the `mainGroup`. Useful for querying the `'Frameworks'` group.
     *
     * @returns The main group child group for the given `name` or a new group if it doesn't exist.
     */
    ensureMainGroupChild(name) {
        return (this.props.mainGroup
            .getChildGroups()
            .find((group) => group.getDisplayName() === name) ??
            // If this happens for the 'Frameworks' group, there's a big problem. But just in case...
            this.props.mainGroup.createGroup({
                name: name,
                sourceTree: "<group>",
            }));
    }
    /** @returns the `Frameworks` group and ensuring it exists. */
    getFrameworksGroup() {
        return this.ensureMainGroupChild("Frameworks");
    }
    createNativeTarget(json) {
        const file = PBXNativeTarget_1.PBXNativeTarget.create(this.getXcodeProject(), json);
        this.props.targets.push(file);
        return file;
    }
    getNativeTarget(type) {
        for (const target of this.props.targets) {
            if (PBXNativeTarget_1.PBXNativeTarget.is(target) && target.props.productType === type) {
                return target;
            }
        }
        return null;
    }
    /** Best effort helper method to return the main target for a given app type. */
    getMainAppTarget(type = "ios") {
        const MAPPING = {
            ios: "IPHONEOS_DEPLOYMENT_TARGET",
            macos: "MACOSX_DEPLOYMENT_TARGET",
            tvos: "TVOS_DEPLOYMENT_TARGET",
            watchos: "WATCHOS_DEPLOYMENT_TARGET",
        };
        const targetBuildSetting = MAPPING[type];
        const anyAppTarget = this.props.targets.filter((target) => {
            return (PBXNativeTarget_1.PBXNativeTarget.is(target) &&
                target.props.productType === "com.apple.product-type.application");
        });
        const mainAppTarget = anyAppTarget.filter((target) => {
            // TODO: This needs to support `baseConfigurationReference` too, otherwise all the settings won't be present.
            const config = target.getDefaultConfiguration();
            // WatchOS apps look very similar to iOS apps, but they have a different deployment target
            return targetBuildSetting in config.props.buildSettings;
        });
        if (mainAppTarget.length > 1) {
            console.warn(`Multiple main app targets found, using first one: ${mainAppTarget
                .map((t) => t.getDisplayName())
                .join(", ")}}`);
        }
        const target = mainAppTarget[0];
        if (!target) {
            // NOTE: This is a fallback since we don't support `baseConfigurationReference` yet.
            if (type === "ios" && anyAppTarget.length) {
                return anyAppTarget[0];
            }
            throw new Error("No main app target found");
        }
        return target;
    }
    isReferencing(uuid) {
        if ([
            this.props.mainGroup.uuid,
            this.props.buildConfigurationList.uuid,
            this.props.productRefGroup?.uuid,
        ].includes(uuid)) {
            return true;
        }
        return !!this.props.targets.find((target) => target.uuid === uuid);
    }
}
exports.PBXProject = PBXProject;
PBXProject.isa = json.ISA.PBXProject;
//# sourceMappingURL=PBXProject.js.map