"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultipleLineComment = exports.Comment = exports.WhiteSpace = exports.StringLiteral = exports.QuotedString = exports.DataLiteral = exports.Colon = exports.Separator = exports.Terminator = exports.ArrayEnd = exports.ArrayStart = exports.ObjectEnd = exports.ObjectStart = void 0;
const chevrotain_1 = require("./chevrotain");
const unicode_1 = require("../unicode");
exports.ObjectStart = (0, chevrotain_1.createToken)({ name: "OpenBracket", pattern: /{/ });
exports.ObjectEnd = (0, chevrotain_1.createToken)({ name: "CloseBracket", pattern: /}/ });
exports.ArrayStart = (0, chevrotain_1.createToken)({ name: "ArrayStart", pattern: /\(/ });
exports.ArrayEnd = (0, chevrotain_1.createToken)({ name: "ArrayEnd", pattern: /\)/ });
exports.Terminator = (0, chevrotain_1.createToken)({ name: "Terminator", pattern: /;/ });
exports.Separator = (0, chevrotain_1.createToken)({ name: "Separator", pattern: /,/ });
exports.Colon = (0, chevrotain_1.createToken)({ name: "Colon", pattern: /=/ });
function matchQuotedString(text, startOffset) {
    let quote = text.charAt(startOffset);
    if (quote !== `'` && quote !== `"`) {
        return null;
    }
    const reg = new RegExp(`${quote}(?:[^\\\\${quote}]|\\\\(?:[bfnrtv${quote}\\\\/]|u[0-9a-fA-F]{4}))*${quote}`, "y");
    // using 'y' sticky flag (Note it is not supported on IE11...)
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky
    reg.lastIndex = startOffset;
    // Note that just because we are using a custom token pattern
    // Does not mean we cannot implement it using JavaScript Regular Expressions...
    const execResult = reg.exec(text);
    if (execResult !== null) {
        const fullMatch = execResult[0];
        // compute the payload
        // const matchWithOutQuotes = fullMatch.substring(1, fullMatch.length - 1);
        // const matchWithOutQuotes = JSON.stringify(
        //   fullMatch.substring(1, fullMatch.length - 1)
        // );
        const matchWithOutQuotes = (0, unicode_1.stripQuotes)(fullMatch.substring(1, fullMatch.length - 1));
        // attach the payload
        // @ts-expect-error
        execResult.payload = matchWithOutQuotes;
    }
    return execResult;
}
const dataLiteralPattern = /<[0-9a-fA-F\s]+>/y;
function matchData(text, startOffset) {
    if (text.charAt(startOffset) !== `<`) {
        return null;
    }
    // using 'y' sticky flag (Note it is not supported on IE11...)
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky
    dataLiteralPattern.lastIndex = startOffset;
    // Note that just because we are using a custom token pattern
    // Does not mean we cannot implement it using JavaScript Regular Expressions...
    const execResult = dataLiteralPattern.exec(text);
    if (execResult !== null) {
        const fullMatch = execResult[0];
        // compute the payload
        const matchWithOutQuotes = fullMatch
            .substring(1, fullMatch.length - 2)
            .trim();
        // attach the payload
        // @ts-expect-error
        execResult.payload = Buffer.from(matchWithOutQuotes);
        // TODO: validate buffer (even number)
    }
    return execResult;
}
exports.DataLiteral = (0, chevrotain_1.createToken)({
    name: "DataLiteral",
    pattern: { exec: matchData },
    line_breaks: false,
    start_chars_hint: [`<`],
});
exports.QuotedString = (0, chevrotain_1.createToken)({
    name: "QuotedString",
    pattern: { exec: matchQuotedString },
    line_breaks: false,
    // Optional property that will enable optimizations in the lexer
    // See: https://chevrotain.io/documentation/10_1_2/interfaces/itokenconfig.html#start_chars_hint
    start_chars_hint: [`"`, `'`],
});
exports.StringLiteral = (0, chevrotain_1.createToken)({
    name: "StringLiteral",
    pattern: /[\w_$/:.-]+/,
    line_breaks: false,
});
exports.WhiteSpace = (0, chevrotain_1.createToken)({
    name: "WhiteSpace",
    pattern: /[ \t\n\r]+/u,
    // pattern: /[ \t\n\r\x0A\x0D\u{2028}\u{2029}\x09\x0B\x0C\x20]+/u,
    group: chevrotain_1.Lexer.SKIPPED,
});
const AbsComment = (0, chevrotain_1.createToken)({ name: "AbsComment", pattern: chevrotain_1.Lexer.NA });
exports.Comment = (0, chevrotain_1.createToken)({
    name: "Comment",
    pattern: /\/\/.*/,
    categories: AbsComment,
    group: chevrotain_1.Lexer.SKIPPED,
});
exports.MultipleLineComment = (0, chevrotain_1.createToken)({
    name: "MultipleLineComment",
    pattern: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//,
    categories: AbsComment,
    // note that comments could span multiple lines.
    // forgetting to enable this flag will cause inaccuracies in the lexer location tracking.
    line_breaks: true,
    group: chevrotain_1.Lexer.SKIPPED,
});
// Labels only affect error messages and Diagrams.
exports.ObjectStart.LABEL = "'{'";
exports.ObjectEnd.LABEL = "'}'";
exports.ArrayStart.LABEL = "'('";
exports.ArrayEnd.LABEL = "')'";
exports.Terminator.LABEL = "';'";
exports.Colon.LABEL = "'='";
exports.Separator.LABEL = "','";
exports.default = [
    // the order is important !!!!
    exports.WhiteSpace,
    // Comments
    exports.Comment,
    exports.MultipleLineComment,
    // etc..
    exports.ObjectStart,
    exports.ObjectEnd,
    exports.ArrayStart,
    exports.ArrayEnd,
    exports.Terminator,
    exports.Separator,
    exports.Colon,
    // Data Types
    exports.DataLiteral,
    exports.QuotedString,
    exports.StringLiteral,
];
//# sourceMappingURL=identifiers.js.map