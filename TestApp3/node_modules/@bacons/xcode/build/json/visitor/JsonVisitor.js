"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonVisitor = void 0;
const parser_1 = require("../parser/parser");
/** Converts a CST for `pbxproj` into a JSON representation. */
class JsonVisitor extends parser_1.BaseVisitor {
    constructor() {
        super();
        this.context = {};
        // The "validateVisitor" method is a helper utility which performs static analysis
        // to detect missing or redundant visitor methods
        this.validateVisitor();
    }
    head(ctx) {
        if (ctx.array) {
            this.context = this.visit(ctx.array);
        }
        else if (ctx.object) {
            this.context = this.visit(ctx.object);
        }
    }
    object(ctx) {
        return (ctx.objectItem?.reduce((prev, item) => ({
            ...prev,
            ...this.visit(item),
        }), {}) ?? {});
    }
    array(ctx) {
        return ctx.value?.map((item) => this.visit(item)) ?? [];
    }
    objectItem(ctx) {
        return {
            [this.visit(ctx.identifier)]: this.visit(ctx.value),
        };
    }
    identifier(ctx) {
        // console.log(ctx);
        if (ctx.QuotedString) {
            return ctx.QuotedString[0].payload ?? ctx.QuotedString[0].image;
        }
        else if (ctx.StringLiteral) {
            const literal = ctx.StringLiteral[0].payload ?? ctx.StringLiteral[0].image;
            return parseType(literal);
        }
        throw new Error("unhandled: " + ctx);
    }
    value(ctx) {
        if (ctx.identifier) {
            return this.visit(ctx.identifier);
        }
        else if (ctx.DataLiteral) {
            return ctx.DataLiteral[0].payload ?? ctx.DataLiteral[0].image;
        }
        else if (ctx.object) {
            return this.visit(ctx.object);
        }
        else if (ctx.array) {
            return this.visit(ctx.array);
        }
        throw new Error("unhandled: " + ctx);
    }
}
exports.JsonVisitor = JsonVisitor;
function parseType(literal) {
    if (
    // octal should be parsed as string not a number to preserve the 0 prefix
    /^0\d+$/.test(literal)) {
        return literal;
    }
    else if (
    // Try decimal
    /^[+-]?([0-9]+\.?[0-9]*|\.[0-9]+)$/.test(literal)) {
        // decimal that ends with a 0 should be parsed as string to preserve the 0
        if (/0$/.test(literal)) {
            return literal;
        }
        try {
            const num = parseFloat(literal);
            if (!isNaN(num))
                return num;
        }
        catch { }
    }
    else if (
    // Try integer
    /^\d+$/.test(literal)) {
        try {
            const num = parseInt(literal, 10);
            if (!isNaN(num))
                return num;
        }
        catch { }
    }
    // Return whatever is left
    return literal;
}
//# sourceMappingURL=JsonVisitor.js.map